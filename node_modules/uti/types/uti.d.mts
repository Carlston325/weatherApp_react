/**
 * Registry of UTIs.
 * @property {Map<string,UTI>} registry
 * @property {Map<string,UTI>} utiByMimeType
 * @property {Map<string,UTI>} utiByFileNameExtension
 */
export class UTIController {
    /** @type {Map<string,UTI>} */ registry: Map<string, UTI>;
    /** @type {Map<string,string[]>} */ utiByMimeType: Map<string, string[]>;
    /** @type {Map<string,string[]>} */ utiByFileNameExtension: Map<string, string[]>;
    /**
     * Registers additional types.
     * @param {UTI[]} types
     */
    register(types: UTI[]): void;
    /**
     * Lookup a given UTI.
     * @param {string} name UTI
     * @return {UTI|undefined} UTI for the given name or undefined if UTI is not present.
     */
    getUTI(name: string): UTI | undefined;
    /**
     * Lookup a UTIs for a mime type.
     * @param {string} mimeType mime type to get UTIs for
     * @return {string[]} UTIs for the given mime type
     */
    getUTIsForMimeType(mimeType: string): string[];
    /**
     * Lookup a UTI for a file name.
     * First the file name extension is extracted.
     * Then a lookup in the registered UTIs for file name extension is executed.
     * @param {string} fileName file to detect UTI for
     * @return {string[]} UTIs for the given fileName
     */
    getUTIsForFileName(fileName: string): string[];
    /**
     * Check whenever two UTI are conformant.
     * If a conforms to b and b conforms to c then a also conforms to c.
     * @param {string} a first UTI
     * @param {string} b second UTI
     * @return {boolean} true if UTI a conforms to UTI b.
     */
    conformsTo(a: string, b: string): boolean;
    /**
     * Lookup a UTI for a file name and check conformance.
     * @param {string} fileName file to detect UTI for
     * @param {string} uti to check conformance against
     * @return {boolean} true if utils for file name are conformant
     */
    fileNameConformsTo(fileName: string, uti: string): boolean;
    /**
     * Assign mime types to a UTI
     * @param {string} uti
     * @param {string[]} mimeTypes
     */
    assignMimeTypes(uti: string, mimeTypes: string[]): void;
    /**
     * Assign mime types to a UTI
     * @param {string} uti
     * @param {string[]} extensions
     */
    assignExtensions(uti: string, extensions: string[]): void;
}
/**
 * Object representing a UTI.
 * @param {string} name
 * @param {Set<UTI>} conforms
 *
 * @property {string} name
 * @property {Set<UTI>} conforms
 */
declare class UTI {
    /**
     * Object representing a UTI.
     * @param {string} name
     * @param {Set<UTI>} conforms
     *
     * @property {string} name
     * @property {Set<UTI>} conforms
     */
    constructor(name: string, conforms: Set<UTI>);
    /** @type {string} */ name: string;
    /** @type {Set<UTI>} */ conforms: Set<UTI>;
    /**
     * Check for conformity.
     * @param {UTI|undefined} other
     * @return {boolean} true if other conforms to the receiver
     */
    conformsTo(other: UTI | undefined): boolean;
    /**
     * name of the UTI.
     * @returns {string}
     */
    toString(): string;
    /**
     * Deliver JSON representation of the UTI.
     * Sample result
     * ```json
     * {
     *   "name": "myUTI",
     *   "conformsTo": [ "uti1", "uti2"]
     * }
     * ```
     * @return {{name:string, conforms: string[]}} json representation of the UTI
     */
    toJSON(): {
        name: string;
        conforms: string[];
    };
}
export {};
